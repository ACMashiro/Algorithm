/*********************************************************
  file name: hdu2475.cpp
  author : kereo
  create time:  2015年08月18日 星期二 15时05分41秒
*********************************************************/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<set>
#include<map>
#include<vector>
#include<stack>
#include<cmath>
#include<string>
#include<algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int sigma_size=26;
const int N=100+50;
const int MAXN=100000+50;
const int inf=0x3fffffff;
const double eps=1e-8;
const int HASH=100007;
const int mod=1000000000+7;
#define L(x) ((x)<<1)
#define R(x) ((x)<<1|1)
#define Ls(x) ((x)->ch[0])
#define Rs(x) ((x)->ch[1])
#define PII pair<int, int>
#define mk(x,y) make_pair((x),(y))
#define REP(i,a,b) for(int i=(int)a;i<=(int)b;i++)
#define REPF(i,a,b) for(int i=(int)a;i>=(int)b;i--)
#define FOR(i,v) for(__typeof((v).begin()) i=(v).begin();i!=(v).end();i++)
struct Node{
	Node *ch[2],*fa;
}*node[MAXN],pool[MAXN],*null,*tail;
struct LCT{
	inline void init(){
		tail=pool; 
		null=node[0]=tail++;
		null->fa=Ls(null)=Rs(null)=null;
	}
	inline bool is_root(Node *x){
		return x->fa == null || x->fa->ch[0]!=x && x->fa->ch[1]!=x;
	}
	inline Node* find_root(Node *x){
		Access(x);
		while(x->ch[0]!=null)
			x=x->ch[0];
		return x;
	}
	inline void rotate(Node *x,int d){
		Node *y=x->fa;
		y->ch[d^1]=x->ch[d]; 
		x->ch[d]->fa=y; x->fa=y->fa;
		if(y->fa!=null){
			int d=y->fa->ch[0] == y ? 0 : 1 ;
			y->fa->ch[d]=x;
		}
		x->ch[d]=y; y->fa=x;
	}
	inline void splay(Node *x){ //旋转到当前Auxiliary Tree的根
		while(!is_root(x)){
			Node *y=x->fa;
			if(is_root(y)){
				int d=y->ch[0] == x ? 1 : 0;
				rotate(x,d);
			}
			else{
				int d=y->fa->ch[0] == y ? 1 : 0;
				if(y->ch[d] == x)
					rotate(x,d^1);
				else
					rotate(y,d);
				rotate(x,d);
			}
		}
	}
	inline void Access(Node *x){
		Node *tmp=null,*rt=x;
		while(x!=null){
			splay(x);
			//Rs(x)->fa=x; 
			x->ch[1]->fa=tmp; 
			if(tmp!=null)
				tmp->fa=x;
			tmp=x; x=x->fa;
		}
		splay(rt);
	}
	inline void Cut(Node *x){
		Access(x);
		if(x->ch[0]!=null){
			x->ch[0]->fa=null; x->ch[0]=null;
		}
	}
	inline void Link(Node *x,Node *rt){
		if(rt == null){
			Cut(x);
			return ;
		}
		if(find_root(x) == find_root(rt))
			return ;
		x->fa=rt; Access(x);
	}
	inline void newnode(Node *&x,Node *fa){
		x=tail++;
		x->fa=fa; Ls(x)=Rs(x)=null;
	}
	int Query(Node *x){
		Access(x);
		while(Ls(x)!=null)
			x=Ls(x);
		return x-pool;
	}
}lct;
int n,m;
char op[N];
int main(){
	freopen("in.txt","r",stdin);
	int first=1;
	while(~scanf("%d",&n)){
		if(first)
			first=0;
		else
			printf("\n");
		lct.init();
		REP(i,1,n){
			int pos;
			scanf("%d",&pos);
			lct.newnode(node[i],pool+pos);
		}
		/*REP(i,0,n){
			printf("i=%d fa=%d\n",i,node[i]->fa-pool);
		}*/
		scanf("%d",&m);
		while(m--){
			scanf("%s",op);
			if(strcmp(op,"MOVE") == 0){
				int u,v;
				scanf("%d%d",&u,&v);
				lct.Link(node[u],node[v]);
			}
			else if(strcmp(op,"QUERY") == 0){
				int x;
				scanf("%d",&x);
				int ans=lct.Query(node[x]);
				printf("%d\n",ans);
			}
		}
	}
	return 0;
}
